# -*- coding: utf-8 -*-
"""Vector_Exercises.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qa-Vd7z4myptc1m5Ce62X8N3R1YSpq07

#1. Vector and Matrix

1.1 Length of a vector
"""

import numpy as np

def compute_vector_length(vector):
  for i in range(len(vector)):
    len_of_vector = np.sqrt(np.sum(np.square(vector)))
  return len_of_vector

print(compute_vector_length([3, 4]))

"""1.2 Dot product"""

def compute_dot_product(vector1, vector2):
  dot_product = np.array(vector1) * np.array(vector2)
  dot_product = np.sum(dot_product)
  return dot_product

print(compute_dot_product([1, 2, 3], [4, 5, 6]))

"""1.3 Mutiplying a vector by a matrix"""

def multiply_vector_by_matrix(vector, matrix):
  result = np.dot(vector, matrix)
  return result

print("Result:", multiply_vector_by_matrix([1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]]))

"""1.4 Multiplying a matrix by a matrix"""

def multiply_matrix_by_matrix(matrix1, matrix2):
  result = np.dot(matrix1, matrix2)
  return result

print(multiply_matrix_by_matrix([[1, 2], [3, 4]], [[5, 6], [7, 8]]))

"""1.5 Reverse Matrix

*   Matrix **A**: **A** =
$\begin{bmatrix}
 a & b \\
 c & d
\end{bmatrix}$ , **A** ∈ $\mathbb{R}^{2*2}$

*   Determinant of **A** ∈ $\mathbb{R}^{2*2}$: det(**A**) = ad - bc
*   if det(**A**) $\neq$ 0, **A** is invertible
*   Inverse Matrix **$A^{-1}$** = $\frac{1}{det(A)}  \begin{bmatrix} d & -b \\ -c & a \end{bmatrix}$
"""

def inverse_matrix(matrix):
  det = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0]
  return np.linalg.inv(matrix)

print(inverse_matrix([[1, 2], [3, 4]]))

"""#2. Eigenvector and Eigenvalues

2.1 Eigenvector and Eigenvalues

*   **A** ∈ $\mathbb{R}^{n*n}$, **I** (Identity matrix) ∈ $\mathbb{R}^{n*n}$, **v** ∈ $\mathbb{R}^{n}$
*   Eigenvalue (λ): *det*(**A** - λ**I**) = 0
*   Eigenvector (**v**): **Av** = λ**v** ⇐⇒ (**A** - λ**I**)**v** = 0
*   Nomarlize vector: $\frac{v}{\left \| v \right \|}$, $v_{i} = \frac{v_{i}}{\sqrt{\sum_{1}^{n}v_{i}^{2}}}$
"""

def compute_eigenvalues_and_eigenvectors(matrix):
    eigenvalues = np.linalg.eig(matrix)[0]
    eigenvectors = np.linalg.eig(matrix)[1]
    return eigenvalues, eigenvectors

print(compute_eigenvalues_and_eigenvectors([[1, 2], [3, 4]]))

"""#3. Cosine Similarity

3.1 Cosine Similarity

*   Data (vector **x**, **y**): $x = \left \{x_{1}, ..., x_{N}\right \}y =\left \{{y_{1}, ..., y_{N}}\right \}$
*   Cosine Similarity: cs(**x**,**y**) = $\frac{x\cdot y}{\left \| x \right \|\left \| y \right \|}$ = $\frac{\sum _{i}^{n}x_{i}y_{i}}{\sqrt{\sum_{1}^{n}x_{i}^{2}}\sqrt{\sum_{1}^{n}y_{i}^{2}}}$
"""

def compute_cosine_similarity(vector1, vector2):
  dot_product = np.dot(vector1, vector2)
  len_of_vector1 = np.sqrt(np.sum(np.square(vector1)))
  len_of_vector2 = np.sqrt(np.sum(np.square(vector2)))
  cosine_similarity = dot_product / (len_of_vector1 * len_of_vector2)
  return cosine_similarity

print(compute_cosine_similarity([1, 2, 3], [4, 5, 6]))

"""#4. Background Subtraction"""

import numpy as np
from google.colab.patches import cv2_imshow
import cv2

bg1_image = cv2.imread('/content/GreenBackground.png', 1)
bg1_image = cv2.resize(bg1_image, (678, 381))

bg2_image = cv2.imread('/content/NewBackground.jpg', 1)
bg2_image = cv2.resize(bg2_image, (678, 381))

ob_image = cv2.imread('/content/Object.png', 1)
ob_image = cv2.resize(ob_image, (678, 381))

def compute_difference(bg_img, input_img):
  difference_single_channel = cv2.absdiff(bg_img, input_img)
  return difference_single_channel
difference_single_channel = compute_difference(bg1_image, ob_image)
cv2_imshow(difference_single_channel)

def compute_binary_mask(difference_single_channel):
  _, binary_mask = cv2.threshold(difference_single_channel, 25, 255, cv2.THRESH_BINARY)
  return binary_mask

binary_mask = compute_binary_mask(difference_single_channel)
cv2_imshow(binary_mask)

def replace_background(bg1_image, bg2_image, ob_image):
  difference_single_channel = compute_difference(bg1_image, ob_image)
  binary_mask = compute_binary_mask(difference_single_channel)
  output = np.where(binary_mask == 255, ob_image, bg2_image)
  return output

final_image = replace_background(bg1_image, bg2_image, ob_image)
cv2_imshow(final_image)

"""#Exercises:

Question 1:
"""

vector = np.array([-2, 4, 9, 21])
result = compute_vector_length(vector)
print(round(result, 2))

"""Question 2:"""

v1 = np.array([0, 1, -1, 2])
v2 = np.array([2, 5, 1, 0])
result = compute_dot_product(v1, v2)
print(result)

"""Question 3:"""

x = np.array([[1, 2],
             [3, 4]])
k = np.array([1, 2])
print('Result:\n', x.dot(k))

"""Question 4:"""

x = np.array([[-1, 2],
             [3, -4]])
k = np.array([1, 2])
print('Result:\n', x@k)

"""Question 5:"""

m = np.array([[-1, 1, 1], [0, -4, 9]])
v = np.array([0, 2, 1])
result = multiply_vector_by_matrix(m, v)
print(result)

"""Question 6:"""

m1 = np.array ([[0, 1, 2], [2, -3, 1]])
m2 = np.array ([[1, -3], [6, 1], [0, -1]])
result = multiply_matrix_by_matrix(m1, m2)
print(result)

"""Question 7:"""

m1 = np.eye(3)
m2 = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])
result = m1@m2
print(result)

"""Question 8:"""

m1 = np.eye(2)
m1 = np.reshape(m1, (-1,4))[0]
m2 = np.array([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]])
result = m1@m2
print(result)

"""Question 9"""

m1 = np.array([[1, 2], [3, 4]])
m1 = np.reshape(m1, (-1, 4), "F")[0]
m2 = np.array([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]])
result = m1@m2
print(result)

"""Question 10:"""

m1 = np.array([[ -2, 6], [8 , -4]])
result = inverse_matrix(m1)
print(result)

"""Question 11:"""

matrix = np.array([[0.9, 0.2], [0.1, 0.8]])
eigenvalues, eigenvectors = compute_eigenvalues_and_eigenvectors(matrix)
print(eigenvectors)

"""Question 12:"""

x = np.array([1, 2, 3, 4])
y = np.array([1, 0, 3, 0])
result = compute_cosine_similarity(x,y)
print(round(result, 3))